1's compilement - flip the digit of the binary number you will get the 1's compilement
2's compilement - first do 1's compilement and then add 1 to that binary number.(also represented as -i)
Right shift(>>) - e.g right shift by 1 means remove right most bit and add 0 at left
                (shortcut -  x >> k means x/(2^k))
Left Shift(<<) - e.g left shift by 1 means remove the left most bit and add 0 at the right.
                (shortcut - x << k means x*2^k)

(2^31 -1) << 1 - it will give overflow.

when computer stored negative number by using 31 position as sign bit. here 0 is for +ve value and 
for negative it convert the number into 2's compilement and then store  the left mostbit as signbit.

larget Int value = 2^31 -1 (INT_MAX)
smallest Int value = -2^31

XOR(^) - even no. of 1's = 0, odd no. of 1's =  1
Not(~) = flip the bits
        - if not of positive number we are taking then 
        - first filp and then check 31's bit is 0 or 1 if 1
        - then take 2's compilement then stored in computer.

        - if taking not of -ve number 
        - first take 2's compilement and then flip 
        - then check sign bit if it is 0 stop else 1 then
        -take 2's compilement then stored in computer.